import pandas as pdimport numpy as npfrom datetime import timedeltafrom datetime import datetimedef extend_biweekly_dates(df, years=5):    df['Date'] = pd.to_datetime(df['Date'])    # Ensure the dataframe is sorted by date    df = df.sort_values('Date')    # Get the last date    last_date = df['Date'].max()    end_date = last_date + pd.DateOffset(years=years)    # Generate new biweekly dates    new_dates = []    current_date = last_date + timedelta(days=14)    while current_date <= end_date:        new_dates.append(current_date)        current_date += timedelta(days=14)    # Create DataFrame for new dates with NaN Amounts    new_df = pd.DataFrame({        'Date': new_dates,        'Amount': [float('nan')] * len(new_dates)    })    # Ensure original has Amount column    if 'Amount' not in df.columns:        df['Amount'] = float('nan')    # Combine and return    extended_df = pd.concat([df, new_df], ignore_index=True)    return extended_dfdef pseudopaychecks(pc):    filled_amounts = pc['Amount'].dropna()    mean = filled_amounts.mean()    std = filled_amounts.std()        num_missing = pc['Amount'].isna().sum()    random_values = np.round(np.random.uniform(mean - std, mean + std, size=num_missing), 2)    pc.loc[pc['Amount'].isna(), 'Amount'] = random_values    return pcimport pandas as pddef expand_monthly_expenses(bills_csv_path: str, start_date: str, end_date: str, output_csv_path: str):    """    Generate a new CSV with each bill repeated monthly from start_date to end_date.    Parameters:        bills_csv_path (str): Path to the input CSV with columns: 'Date' (day of month), 'Nickname', 'Amount'.        start_date (str): Start of the range in 'YYYY-MM-DD' format.        end_date (str): End of the range in 'YYYY-MM-DD' format.        output_csv_path (str): Path to write the new expanded CSV.    Returns:        pd.DataFrame: The expanded DataFrame.    """    # Load the original bills    bills = pd.read_csv(bills_csv_path)    # Convert start and end to datetime    start = pd.to_datetime(start_date)    end = pd.to_datetime(end_date)    # Generate the 1st of each month between start and end    all_months = pd.date_range(start=start, end=end, freq='MS')    # Build the expanded list of bills    expanded_rows = []    for _, row in bills.iterrows():        day = int(row['Date'])  # Day of the month the bill is due        for month_start in all_months:            try:                due_date = month_start.replace(day=day)                expanded_rows.append({                    'Date': due_date,                    'Nickname': row['Nickname'],                    'Amount': row['Amount']                })            except ValueError:                # Skip if day is invalid for the month (e.g., Feb 30)                continue    # Create final DataFrame    expanded_df = pd.DataFrame(expanded_rows).sort_values('Date').reset_index(drop=True)    # Save to CSV    expanded_df.to_csv(output_csv_path, index=False)    return expanded_dfdef simulate_loc(ledger, starting_balance, loc_limit):    ledger = ledger.sort_values('Date').reset_index(drop=True)    balance = starting_balance    current_month = None    for _, row in ledger.iterrows():        date = row['Date']        amount = row['Amount']        balance += amount        # LOC limit check        if balance < loc_limit:            print("\n" + "!" * 60)            print("ðŸš¨ðŸš¨ðŸš¨ LOC LIMIT BREACHED ðŸš¨ðŸš¨ðŸš¨")            print(f"Date: {date.strftime('%Y-%m-%d')}")            print(f"Balance: ${balance:,.2f} | Limit: ${loc_limit:,.2f}")            print("!" * 60 + "\n")            return  # Stop simulation immediately        # Detect when we've moved to a new month        if current_month is None:            current_month = (date.year, date.month)        next_month = (date.year, date.month)        if next_month != current_month:            print(f"End of {current_month[0]}-{current_month[1]:02d}: LOC Balance = ${balance:,.2f}")            current_month = next_month    # Final month print    print(f"End of {current_month[0]}-{current_month[1]:02d}: LOC Balance = ${balance:,.2f}")# sim.pyimport pandas as pdimport numpy as npfrom datetime import datetime, timedeltaclass CreditCard:    def __init__(self, nickname, balance, limit, apr, min_payment, holder):        self.nickname = nickname        self.balance = float(balance)        self.limit = float(limit)        self.apr = float(apr)        self.monthly_rate = self.apr / 12 / 100        self.min_payment = float(min_payment)        self.holder = holder        self.payment_history = []        self.total_interest_paid = 0.0    def apply_payment(self, amount):        interest = self.balance * self.monthly_rate if self.balance > 0 else 0        self.total_interest_paid += interest        self.balance += interest        actual_payment = min(amount, self.balance)        self.balance -= actual_payment        self.payment_history.append({            'payment': actual_payment,            'interest': interest,            'balance_after': self.balance        })        return actual_payment    def is_paid_off(self):        return self.balance <= 0    def current_state(self):        return {            'nickname': self.nickname,            'holder': self.holder,            'balance': round(self.balance, 2),            'min_payment': self.min_payment,            'monthly_rate': self.monthly_rate,            'interest_paid': round(self.total_interest_paid, 2)        }# Load and clean debt CSVdebts_df = pd.read_csv("Debts-CC.csv")for col in ['Limit', 'Balance', 'APR', 'Minimum Payment']:    debts_df[col] = debts_df[col].replace({',': ''}, regex=True).astype(float)cards = [    CreditCard(        nickname=row['Nickname'],        balance=row['Balance'],        limit=row['Limit'],        apr=row['APR'],        min_payment=row['Minimum Payment'],        holder=row['Names on Account']    )    for _, row in debts_df.iterrows()]def apply_monthly_payments(cards, surplus):    total_minimum = 0    for card in cards:        if not card.is_paid_off():            total_minimum += card.apply_payment(card.min_payment)    remaining = surplus - total_minimum    if remaining > 0:        remaining_cards = sorted([c for c in cards if not c.is_paid_off()], key=lambda c: (-c.apr, -c.balance))        for card in remaining_cards:            if remaining <= 0:                break            to_pay = min(remaining, card.balance)            remaining -= card.apply_payment(to_pay)def simulate_debt_payoff(cards, monthly_surpluses):    month = 1    for surplus in monthly_surpluses:        if all(card.is_paid_off() for card in cards):            print(f"\nAll debts paid off after {month - 1} months!\n")            break        print(f"\nMonth {month}: Applying surplus of ${surplus:.2f}")        apply_monthly_payments(cards, surplus)        for card in cards:            print(card.current_state())        month += 1    print("\nFinal Debt Summary:")    for card in cards:        print(f"{card.nickname}: Balance ${card.balance:.2f}, Total Interest Paid ${card.total_interest_paid:.2f}")def extract_monthly_surpluses(ledger, starting_balance):    ledger = ledger.sort_values('Date').reset_index(drop=True)    balance = starting_balance    current_month = None    monthly_surpluses = []    for _, row in ledger.iterrows():        date = row['Date']        amount = row['Amount']        balance += amount        month_key = (date.year, date.month)        if current_month is None:            current_month = month_key        if month_key != current_month:            monthly_surpluses.append(max(0, balance))            current_month = month_key    monthly_surpluses.append(max(0, balance))    return monthly_surplusesif __name__ == "__main__":    LOC_LIMIT = -8000.00    LOC_BALANCE = -1*float(input("CURRENT LOC BALANCE: "))    print(LOC_BALANCE)    pc_g = pd.read_csv("Paychecks-Grace.csv", parse_dates=['Date'])    pc_t = pd.read_csv("Paychecks-Tyler.csv", parse_dates=['Date'])    expenses = pd.read_csv("Bills-Expenses.csv")    debts = pd.read_csv("Debts-CC.csv")        pc_g_extended = extend_biweekly_dates(pc_g)    pc_t_extended = extend_biweekly_dates(pc_t)    pc_g_filled = pseudopaychecks(pc_g_extended)    pc_t_filled = pseudopaychecks(pc_t_extended)    pc_g_filled['Nickname'] = 'Grace Paycheck'    pc_t_filled['Nickname'] = 'Tyler Paycheck'    combined = pd.concat([pc_g_filled, pc_t_filled], ignore_index=True)    combined = combined.sort_values(by='Date').reset_index(drop=True)    monthly_expenses = expand_monthly_expenses(    bills_csv_path="Bills-Expenses.csv",    start_date="2025-01-01",    end_date="2030-12-31",    output_csv_path="Expanded-Bills.csv")    # Enforce signs       ledger = pd.concat([combined, monthly_expenses], ignore_index=True)    ledger = ledger.sort_values(by='Date').reset_index(drop=True)    from datetime import datetime# Create a single-row DataFrame with today's LOC balance    loc_row = pd.DataFrame([{        'Date': pd.to_datetime(datetime.today().strftime('%Y-%m-%d')),        'Nickname': 'Current Line of Credit Balance',        'Amount': LOC_BALANCE        }])    # Append it to the ledger    ledger = pd.concat([ledger, loc_row], ignore_index=True)    # Optional: re-sort if needed    ledger = ledger.sort_values(by='Date').reset_index(drop=True)    # Find the index of the LOC row    loc_index = ledger[ledger['Nickname'] == 'Current Line of Credit Balance'].index.max()    # Keep only rows from that point forward    ledger = ledger.loc[loc_index:].reset_index(drop=True)    simulate_loc(ledger, LOC_BALANCE, LOC_LIMIT)     # Extract monthly surplus based on LOC position    monthly_surpluses = extract_monthly_surpluses(ledger, LOC_BALANCE)    # Run the debt payoff simulation    simulate_debt_payoff(cards, monthly_surpluses)   