# Final full working simulation with LOC + credit card payoff strategyimport pandas as pdimport numpy as npimport matplotlib.pyplot as pltimport calendarfrom datetime import datetime, timedelta# -----------------------------# Utility & Core Functions# -----------------------------def get_month_end(date):    last_day = calendar.monthrange(date.year, date.month)[1]    return datetime(date.year, date.month, last_day)def pseudo_paychecks(df):    df.columns = df.columns.str.strip()    known = df['Amount'].dropna().astype(float)    if known.empty:        return df    min_amt = known.min()    max_amt = known.max()    mask = df['Amount'].isna()    random_vals = np.random.uniform(min_amt, max_amt, size=mask.sum())    df.loc[mask, 'Amount'] = np.round(random_vals, 2)    return dfdef combine_paychecks(paycheck1, paycheck2):    paycheck1['Name'] = 'Tyler Paycheck'    paycheck2['Name'] = 'Grace Paycheck'    combined = pd.concat([        paycheck1[['Date', 'Amount', 'Name']],        paycheck2[['Date', 'Amount', 'Name']]    ], ignore_index=True)    combined['Date'] = pd.to_datetime(combined['Date'], errors='coerce')    return combined.sort_values(by='Date').reset_index(drop=True)def date_clipper(df, date_str, date_col='Date'):    df[date_col] = pd.to_datetime(df[date_col], errors='coerce')    target_date = pd.to_datetime(date_str)    return df[df[date_col] >= target_date]def build_movement(expenses, paycheck_schedule, today, LOC_balance):    expenses = expenses[['Date', 'Amount', 'Name']]    paycheck_schedule = paycheck_schedule[['Date', 'Amount', 'Name']]    loc_entry = pd.DataFrame([{        'Date': pd.to_datetime(today),        'Amount': LOC_balance,        'Name': 'Current Line of Credit Balance'    }])    movement = pd.concat([loc_entry, expenses, paycheck_schedule], ignore_index=True)    movement['Date'] = pd.to_datetime(movement['Date'], errors='coerce')    return movement.sort_values(by='Date').reset_index(drop=True)# -----------------------------# Credit Management# -----------------------------def initialize_tracking(debts_df):    tracking = debts_df[['Name', 'Limit', 'Balance', 'APR', 'Minimum Payment', 'Names on Account']].copy()    tracking['History'] = tracking.apply(lambda row: [(None, row['Balance'])], axis=1)    return trackingdef apply_monthly_interest(tracking_df, current_date):    for idx, row in tracking_df.iterrows():        balance = row['Balance']        apr = row['APR']        if balance > 0:            monthly_interest = balance * (apr / 100) / 12            balance += monthly_interest        tracking_df.at[idx, 'Balance'] = round(balance, 2)        tracking_df.at[idx, 'History'].append((current_date, round(balance, 2)))def calculate_monthly_surplus(movement_df, start_date, end_date):    mask = (movement_df['Date'] >= start_date) & (movement_df['Date'] <= end_date)    monthly_data = movement_df.loc[mask]    return round(monthly_data['Amount'].sum(), 2)def optimize_payments(tracking_df, available_cash):    payment_plan = {}    remaining_cash = available_cash    # Step 1: Pay minimums    for idx, row in tracking_df.iterrows():        name = row['Name']        balance = round(row['Balance'], 2)        min_payment = round(row['Minimum Payment'], 2)        if balance <= 0:            payment_plan[name] = 0.0            continue        required = min(min_payment, balance)        payment_plan[name] = required        remaining_cash -= required    # Step 2: Apply surplus to smallest balances first    if remaining_cash > 0:        payable_cards = tracking_df[tracking_df['Balance'] > 0].copy()        payable_cards = payable_cards.sort_values(by='Balance', ascending=True)        for _, row in payable_cards.iterrows():            name = row['Name']            balance = round(row['Balance'], 2)            already_paid = payment_plan.get(name, 0.0)            max_extra = max(0, balance - already_paid)            extra = min(max_extra, remaining_cash)            if extra > 0:                payment_plan[name] = round(already_paid + extra, 2)                remaining_cash -= extra            if remaining_cash <= 0:                break    return payment_plandef update_movement_with_payments(movement_df, payment_plan, next_month):    for name, payment in payment_plan.items():        if payment == 0:            continue        mask = (            (movement_df['Name'] == name) &            (movement_df['Date'].dt.month == next_month.month) &            (movement_df['Date'].dt.year == next_month.year) &            (movement_df['Amount'] == 0)        )        indices = movement_df[mask].index.tolist()        if indices:            movement_df.at[indices[0], 'Amount'] = -1 * round(payment, 2)# -----------------------------# Visualization# -----------------------------def plot_card_balances(tracking_df):    plt.figure(figsize=(12, 5))    for idx, row in tracking_df.iterrows():        card = row['Name']        history = row['History']        dates, balances = zip(*[(d, b) for d, b in history if d is not None])        plt.plot(dates, balances, label=card, marker='o')    plt.title("Credit Card Balances Over Time")    plt.xlabel("Date")    plt.ylabel("Balance ($)")    plt.legend()    plt.grid(True)    plt.tight_layout()    plt.show()def plot_utilization(tracking_df):    grace_hist, tyler_hist = [], []    for month_idx in range(len(tracking_df.iloc[0]['History'])):        grace_bal = grace_lim = tyler_bal = tyler_lim = 0        for _, row in tracking_df.iterrows():            date, bal = row['History'][month_idx]            if date is None: continue            limit = row['Limit']            names = [n.strip() for n in row['Names on Account'].split(',')]            if 'Grace' in names:                grace_bal += bal                grace_lim += limit            if 'Tyler' in names:                tyler_bal += bal                tyler_lim += limit        grace_pct = 100 * grace_bal / grace_lim if grace_lim else 0        tyler_pct = 100 * tyler_bal / tyler_lim if tyler_lim else 0        grace_hist.append((date, grace_pct))        tyler_hist.append((date, tyler_pct))    plt.figure(figsize=(10, 4))    plt.plot(*zip(*grace_hist), label='Grace Utilization', marker='o')    plt.plot(*zip(*tyler_hist), label='Tyler Utilization', marker='o')    plt.title("Credit Utilization Over Time")    plt.ylabel("Utilization (%)")    plt.xlabel("Date")    plt.grid(True)    plt.legend()    plt.tight_layout()    plt.show()# -----------------------------# Monthly Simulation Runner# -----------------------------def simulate_line_of_credit_live(movement, LOC_balance, LOC_limit, LOC_ceiling):    limit_threshold = LOC_limit + LOC_ceiling    month_end_balances = {}    zero_crossings = []    movement = movement.sort_values(by='Date').reset_index(drop=True)    running_balance = LOC_balance    dates = []    balances = []    plt.ion()    fig, ax = plt.subplots(figsize=(10, 5))    line, = ax.plot([], [], marker='o', label="LOC Balance")    ax.set_title("Line of Credit Simulation")    ax.set_xlabel("Date")    ax.set_ylabel("LOC Balance ($)")    ax.grid(True)    ax.axhline(0, color='black', linestyle='--')    ax.axhspan(0, max(0, LOC_balance), facecolor='green', alpha=0.1)    ax.axhspan(min(0, LOC_balance), 0, facecolor='red', alpha=0.1)    print("\n📒 Running Ledger:")    print("-" * 60)    previous_balance = running_balance    for i, row in movement.iterrows():        if i == 0 and row['Name'] == 'Current Line of Credit Balance':            continue        date = row['Date']        name = row['Name']        amount = row['Amount']        running_balance += amount        dates.append(date)        balances.append(running_balance)        sign = "+" if amount >= 0 else "-"        print(f"📅 {date.date()} | {name:<25} {sign}${abs(amount):>8.2f} | Balance: ${running_balance:>9.2f}")        if (previous_balance < 0 and running_balance >= 0) or (previous_balance >= 0 and running_balance < 0):            zero_crossings.append((date, running_balance))            ax.annotate(                f'{date.strftime("%b %d")}',                xy=(date, running_balance),                xytext=(0, 10),                textcoords='offset points',                ha='center',                fontsize=8,                color='blue',                arrowprops=dict(arrowstyle='->', color='blue')            )        previous_balance = running_balance        line.set_data(dates, balances)        ax.relim()        ax.autoscale_view()        plt.xticks(rotation=45)        plt.draw()        plt.pause(0.05)        if running_balance <= limit_threshold:            print(f"\n❌ LOC ceiling breached on {date.date()} (Balance: ${running_balance:.2f})")            break    plt.ioff()    plt.tight_layout()    plt.show(block=True)    if zero_crossings:        print("\n🔄 Balance crossed $0 on these dates:")        for date, balance in zero_crossings:            print(f"📍 {date.strftime('%Y-%m-%d')} | Balance: ${balance:.2f}")    else:        print("\n✅ Balance never crossed $0 during simulation.")def run_monthly_simulation(start_date, movement, tracking_df):    sim_date = pd.to_datetime(start_date)    payment_log = []    paid_off_cards = {}    while sim_date.year == pd.to_datetime(start_date).year:        month_start = sim_date.replace(day=1)        month_end = get_month_end(month_start)        next_month = month_end + timedelta(days=1)        apply_monthly_interest(tracking_df, month_end)        surplus = calculate_monthly_surplus(movement, month_start, month_end)        payment_plan = optimize_payments(tracking_df, surplus)        update_movement_with_payments(movement, payment_plan, next_month)        for idx, row in tracking_df.iterrows():            name = row['Name']            payment = payment_plan.get(name, 0)            tracking_df.at[idx, 'Balance'] = max(0, round(row['Balance'] - payment, 2))        for idx, row in tracking_df.iterrows():            name = row['Name']            if name not in paid_off_cards and round(row['Balance'], 2) <= 0:                paid_off_cards[name] = month_end.date()        record = {'Date': next_month, 'Surplus': round(surplus, 2)}        for card, amt in payment_plan.items():            record[card] = abs(amt)        payment_log.append(record)        sim_date = next_month    return payment_log, paid_off_cards# -----------------------------# MAIN RUN BLOCK# -----------------------------if __name__ == "__main__":    debts_df = pd.read_csv("/Users/gracepuchh/sim/Debts-CC.csv", skiprows=1)    debts_df = debts_df[~debts_df['Institution'].str.contains("Total", na=False)]    debts_df.rename(columns={'Nickname': 'Name'}, inplace=True)    for col in ['Limit', 'Balance', 'APR', 'Minimum Payment']:        debts_df[col] = debts_df[col].astype(str).str.replace(',', '').astype(float)    debts_df['Names on Account'] = debts_df['Names on Account'].fillna('')    expenses = pd.read_csv("/Users/gracepuchh/sim/Bills-Expenses.csv", skiprows=1)    paycheck1 = pd.read_csv("/Users/gracepuchh/sim/Paychecks-Tyler.csv", skiprows=1)    paycheck2 = pd.read_csv("/Users/gracepuchh/sim/Paychecks-Grace.csv", skiprows=1)    paycheck1.rename(columns={'Date Deposited': 'Date'}, inplace=True)    paycheck2.rename(columns={'Date Deposited': 'Date'}, inplace=True)    paycheck1 = pseudo_paychecks(paycheck1)    paycheck2 = pseudo_paychecks(paycheck2)    paycheck_schedule = combine_paychecks(paycheck1, paycheck2)    today = input("Please enter today's date (YYYY-MM-DD): ")    LOC_balance = -1 * float(input("Please enter Line of Credit Balance as of today: $"))    LOC_limit = -1 * float(input("Please enter Line of Credit limit: $"))    LOC_ceiling = -1 * float(input("Please enter emergency fund amount: $"))    expenses = date_clipper(expenses, today)    paycheck_schedule = date_clipper(paycheck_schedule, today)    movement = build_movement(expenses, paycheck_schedule, today, LOC_balance)    tracking_df = initialize_tracking(debts_df)    payment_log, paid_off_cards = run_monthly_simulation(today, movement, tracking_df)    payment_df = pd.DataFrame(payment_log)    payment_df.set_index("Date", inplace=True)    print("\n📊 Monthly Credit Card Payments + Surplus:")    print(payment_df.fillna(0).round(2))    if paid_off_cards:        print("\n✅ Cards paid off:")        for name, date in paid_off_cards.items():            print(f"✅ {name} paid off on {date}")    plot_card_balances(tracking_df)    plot_utilization(tracking_df)    simulate_line_of_credit_live(movement, LOC_balance, LOC_limit, LOC_ceiling)    payment_df.to_csv(f"/Users/gracepuchh/sim/monthly_payment_log_{today}.csv")